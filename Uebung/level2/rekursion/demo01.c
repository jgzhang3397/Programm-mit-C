/*
Test01():
描述
糖和抖m在玩个游戏，规定谁输了就要请谁吃顿大餐：抖m给糖a b c三个驻， 
并在a柱上放置了数量为n的圆盘，圆盘的大小从上到下依次增大，现在要做的事就是把a柱的圆盘全部移到c柱，
移动的过程中保持小盘在上，大盘在下，且限定圆盘只能够移动到相邻的柱子，即a柱子上的圆盘只能够移动到b，
b柱子上的圆盘只能够移动到a或者c，c同理。现在请你设计一个程序，计算所需移动的最小步数， 帮助糖赢得大餐！

输入描述：
每一行输出有一个整数n(0<=n<26), 直至文件末尾。
输出描述：
对于每一组数据，输出一行，输出移动的最小步数M。
    示例1
    输入：
    1
    输出：
    2

解析：
    对于n个盘子，我们可以把它分成个盘子和最后一个大盘子。
    设为移动所需步数f(n)。

    1.将n-1个盘子借助B柱移动到C柱上,这一过程移动的步数为f(n-1)
    2.将大盘子由A柱移动到B柱上，此时需要一步
    3.将n-1个盘子借助B柱移动到A柱上,这一过程移动的步数同样为f(n-1)
    4.将大盘子由B柱移动到C柱上，此时需要一步
    5.将个盘子借助B柱子移动到C柱上，此时需要的步数仍为f(n-1)
    综合以上分析 f(n) = 3*f(n-1) + 2
    同样，对两边同时加上1可以凑成一个等比数列，最后求出其通项公式即为3^n-1。
*/
#include<stdio.h>
int func(int n)
{
    if(n==1){return 2;}
    return (3*func(n-1) + 2) ;
}
void Test01()
{
    int n;
    while (scanf("%d", &n)!=EOF)
    {
        int result = func(n);
        printf("%d\n", result);
    }
}

/*
Test02():
汉诺塔问题
相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。
该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，
在A杆自下而上、由大到小按顺序放置64个金盘(如下图)
。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。

操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，
小盘在上，操作过程中盘子可以置于A、B、C任一杆上。

解析：
    对于n个盘子，我们可以把它分成个盘子和最后一个大盘子。
    1.设为移动所需步数f[n],那么对于n-1个盘子来说所做的事情就是将个盘子借助C柱移动到B柱上,
      这一过程移动的步数为f[n-1],
    2.下一步我们将大盘子移动到C柱上，此时需要一步，
    3.最后，我们再将个n-1盘子借助A柱移动到C柱上，此时需要的步数仍为f[n-1]。
    综合以上分析 f[n] = 2f[n-1] + 1。
    对两边同时加上1可以凑成一个等比数列，然后就可以求出其通项公式2^n-1。
*/
#include<math.h>
void Test02()
{
    int n;
    int result;
    while(scanf("%d", &n)!=EOF)
    {
        result = pow(2, n) - 1;
        printf("%d\n", result);
    }
}
int main()
{
    //Test01();
    Test02();
    return 0;
}