/*
    ==========浮点数在内存中的存储========
    ===IEEE754===
    (-1)^S * M * 2^E

    9.0
    1001.0 = 1 * 1.001 * 2^3 
    S = 0, M = 1.001, E = 3

    -9.0
    -1001.0 = -1 * 1.001 * 2^3 
    S = 1, M = 1.001, E = 3

    0.5 -- 十进制 
    = 0.1 --二进制
    (-1)^0 * 1.0 * 2^-1 E --> -1 , weil E unsigned int, E 8 位， 0～255，中间值127. E 11 位， 0～2047，中间值1023.
    E 8 位 : E = E + 127 = 126 
    E 11 位： E = E + 1023 = 1022

在内存中存：
    IEEE 754规定：
        对于32位浮点数（单精度--float），最高位S， 接着8位是指数E，剩下23位是有效数字M
        对于64位浮点数（双精度--double），最高位S， 接着11位是指数E，剩下52位是有效数字M
        对于M来说，默认这个数的第一位总是1，因此舍去，只保存后面的部分
指数E从内存中取出来分三种情况
    1.不为全0或全1: 减去127或1023得到真实值，再将有效数字M前加第一位的1
    2.E为全0:      E等于1-127或1-1023为真实值，有效数字M不加第一位的1，还原为0.xxxxxx的小数
    3.E为全1:      
*/
#include<stdio.h>

void Test01()
{
    float f = 5.5;
    //5.5
    //101.1
    //(-1)^0 * 1 * 1.011*2^2
    //S == 0;
    //M == 1.011; 
    //E == 2; E + 127 = 129;
    //S E        M
    //0 10000001 01100000000000000000000
    //0100 0000 1011 0000 0000 0000 0000 0000
    //4    0    b    0 ...
    //0x40b00000

    //0 00000000 01100000000000000000000
    //+/- 0.011 * 2 ^-126

    //0 11111111 01100000000000000000000
    //E + 127 = 255
    //E = 128
    //1.xxxx * 2^128 表示正负无穷大
    printf("%p\n", &f);
}

void Test02()
{
    int n =9;
    //0 000000000 0000000000000000001001 --补码
    //
    float *pFloat = (float *)&n;
    printf("n = %d\n", n);//9
    printf("*pFloat = %f\n", *pFloat);//0.000000
    //(-1)^0 * 0.0000000000000000001001 * 2^-126
    //
    *pFloat = 9.0;
    //1001.0
    //1.001 * 2^3
    //(-1)^0 * 1.001 * 2^3
    //S = 0, E = E + 127 = 130, M = 001+20个0
    //0 10000010 00100000000000000000000
    //0100 0001 0001 0000 0000 0000 0000 0000 --补码
    //正数原反补相同
    printf("n = %d\n", n);//n = 1091567616
    printf("*pFloat = %f\n", *pFloat);//9.000000
}

int main()
{
    //Test01();
    Test02();
    return 0;
}
